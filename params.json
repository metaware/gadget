{"name":"Gadget","tagline":"A smallish web framework for Go","body":"Gadget is a smallish web application framework with a soft spot for content\r\nnegotiation. To install Gadget, just use the go tool.\r\n\r\n```\r\n$ go get github.com/redneckbeard/gadget\r\n```\r\n\r\nThe gdgt package will install a command that will help you generate Gadget\r\nprojects. You don't have to use it, but it does mean mashing fewer buttons. You\r\nneed Go 1.2 to use it.\r\n\r\n```\r\n$ go get github.com/redneckbeard/gadget/gdgt\r\n```\r\n\r\n## Show me how it works!\r\n\r\nThe [README](https://github.com/redneckbeard/gadget/blob/master/README.md) is a\r\nnarrated terminal session of having a first play with Gadget. If that's your\r\nstyle, it may be more helpful than the summaries below.  All the concepts here\r\nare documented more granularly on\r\n[godoc.org](http://godoc.org/github.com/redneckbeard/gadget).\r\n\r\n### Project layout\r\n\r\nFor the most part, you can lay out your Gadget projects however you want. There\r\nis, however, a convention, and you can conform to it most easily by installing\r\nthe `github.com/redneckbeard/gadget/gdgt` subpackage. Using the \"new\" command,\r\nyou can create a ready-to-compile program with the following directory/file\r\nstructure:\r\n\r\n```\r\n.\r\n├── app\r\n│   └── conf.go\r\n├── controllers\r\n│   └── home.go\r\n├── main.go\r\n├── static\r\n│   ├── css\r\n│   ├── img\r\n│   └── js\r\n└── templates\r\n    ├── base.html\r\n    └── home\r\n\t└── index.html\r\n```\r\n\r\nThe app package is where you actually have your Gadget configuration and a\r\npointer to the app object, so you will end up importing that package in files\r\nin the controllers package. main.go also imports app, and actually runs the\r\nthing.\r\n\r\n### Running Gadget\r\n\r\nSince your Gadget application is just a Go package, we can build this with `go\r\ninstall <appname>`, and voilà -- we have a single-file web application / HTTP\r\nserver waiting for as `$GOPATH/bin/<appname>`.\r\n\r\nBecause there are some files that don't go into the build, and the build is\r\njust an executable, Gadget needs an absolute path that it can assume as the\r\nroot that all relative filepaths branch off of. In development, this will often\r\nsimply be the current working directory, and that's the default. However, in\r\nproduction, you might have your binary and your frontend files in completely\r\ndifferent locations. For this reason, we can call the `<appname>` executable\r\nwith a `-root` flag and point it at whatever path we please.\r\n\r\nThe command invoked in an upstart job might then look like:\r\n\r\n```\r\n/usr/local/bin/inspector serve -static=\"/media/\" -root=/home/penny/files/ -debug=false\r\n```\r\n\r\n### Asset files\r\n\r\nGadget assumes that the file root will contain a `static` directory and that\r\nyou want it to serve the contents thereof as files. By default, it will do so\r\nat `/static/`. You can, however, change this to accommodate whatever you have\r\nagainst the word \"static\"... with the `-static` flag.\r\n\r\n## Routing\r\n\r\nRoutes in Gadget are just code. They go in the Configure method of your app in\r\napp/conf.go. \r\n\r\nPeople love HandlerFuncs. So if you want, you can just route stuff to\r\nHandlerFuncs.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.HandleFunc(\"robots.txt\", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, \"templates/robots.txt\") }),\r\n)\r\n```\r\n\r\nIf you have lots of routes with a common URL segment, you can factor it out\r\nwith `Prefixed`.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.Prefixed(\"users\",\r\n\t\tapp.HandleFunc(\"friends\", FriendsIndex),\r\n\t\tapp.HandleFunc(\"frenemies\", FrenemiesIndex),\r\n\t),\r\n)\r\n```\r\n\r\nIn practice, though being able to use HandlerFuncs is very handy, you'll more\r\ncommonly route to RESTful controllers with the `Resource` method.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.Resource(\"users\",\r\n\t\tapp.Resource(\"friends\"),\r\n\t\tapp.Resource(\"frenemies\"),\r\n\t),\r\n)\r\n```\r\n\r\nIn this example, \"users\", \"friends\", and \"frenemies\" all reference controllers\r\nthat we've registered with the app. To mount at route at the root of the site,\r\nthere's a special `SetIndex` method, which is set up for you automatically if\r\nyou use the gdgt project generator.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.SetIndex(\"home\"),\r\n\tapp.Resource(\"users\",\r\n\t\tapp.Resource(\"friends\"),\r\n\t\tapp.Resource(\"frenemies\"),\r\n\t),\r\n)\r\n```\r\n\r\n### Controllers\r\n\r\nThe strings that are fed to the `gadget.Resource` calls correspond to the names\r\nof controllers that we defined in our `controllers` package. The files in the\r\ncontrollers package all declare a `gadget.Controller type, embed a pointer to\r\n`gadget.DefaultController` to make it simpler to implement the controller\r\ninterface, and explicitly register that controller with the framework. \r\n\r\n```Go\r\npackage controllers\r\n\r\nimport (\r\n\t\"github.com/redneckbeard/gadget\"\r\n\t\"example/app\"\r\n)\r\n\r\ntype MissionController struct {\r\n\t*gadget.DefaultController\r\n}\r\n\r\nfunc (c *MissionController) Index(r *gadget.Request) (int, interface{}) {\r\n\treturn 200, []&struct{Mission string}{{\"Dr. Claw\"},{\"M.A.D. Cat\"}}\r\n}\r\n\r\nfunc (c *MissionController) Show(r *gadget.Request) (int, interface{}) {\r\n\tmissionId := r.UrlParams[\"mission_id\"]\r\n\treturn 200, \"Mission #\" + missionId + \": this message will self-destruct.\"\r\n}\r\n\r\nfunc (c *MissionController) ChiefQuimby(r *gadget.Request) (int, interface{}) {\r\n\treturn 200, \"You've done it again, Gadget! Don't know how you do it!\"\r\n}\r\n\r\nfunc init() {\r\n\tapp.Register(&MissionController{})\r\n}\r\n```\r\n\r\nController methods have access to a `gadget.Request` object and return simply\r\nan HTTP status code and any value at all for the body (more on why in a bit).\r\nThe controller interface requires `Index`, `Show`, `Create`, `Update`, and\r\n`Destroy` methods. Embedding a pointer to a `DefaultController` means that\r\nthese are all implemented for you. However, _this doesn't provide you with\r\nanything but 404s_. If you want to take action in response to a particular verb,\r\noverride the method.\r\n\r\nThe Gadget router will hit controller methods based on the HTTP verbs that you\r\nwould expect: \r\n\r\n* `GET /missions` routes to `Index`\r\n* `GET /missions/\\d+` routes to `Show`\r\n* `POST /missions` routes `Create`\r\n* `PUT /missions/\\d+` routes to `Update`\r\n* `PATCH /missions/\\d+` routes to `Update`\r\n* `DELETE /missions/\\d+` routes to `Destroy`\r\n\r\nNumeric ids are the default, but if you want something else in your URLs, just\r\noverride `func IdPattern() string` on your controller.\r\n\r\nIn addition, any exported method on the controller will be routed to for all\r\nHTTP verbs. `ChiefQuimby` above would be called for any verb when the requested\r\npath was `/missions/chief-quimby`.\r\n\r\nYou make a Controller available to the router by passing it to `app.Register`.\r\nThis is best done in the init function. Gadget doesn't pretend to speak\r\nperfect English, so it takes the dumbest possible guess at pluralizing your\r\ncontroller's name and just tacks an \"s\" on the end. If inflecting is more\r\ncomplicated, define a `Plural() string` method on your controller.\r\n\r\n#### Action filters\r\n\r\nWhen developing a web application, you frequently have a short-circuit pattern\r\ncommon to a number of controller methods -- \"404 if the user isn't logged in\",\r\n\"Redirect if the user isn't authorized\", etc. To accommodate code reuse, Gadget\r\ncontrollers allow you to define filters on certain actions. Setting one up in\r\nthe example above might look like this:\r\n\r\n\r\n```Go\r\nfunc init() {\r\n\tc := &MissionController{gadget.New()}\r\n\tc.Filter([]string{\"create\", \"update\", \"destroy\"}, UserIsPenny)\r\n\tgadget.Register(c)\r\n}\r\n```\r\n\r\n`UserIsPenny` is just a function with the signature `func(r *requests.Request)\r\n(int, interface{})` just like a controller method. If this function returns a\r\nnon-zero status code, the controller method that was filtered will never be\r\ncalled. If the filter returns a status code of zero, Gadget will move on to the\r\nnext filter for that action until they are exhausted, and then call the\r\ncontroller method.\r\n\r\n### Request and explicit Response objects\r\n\r\n#### Request objects\r\n\r\n`gadget.Request` embeds `http.Request` and provides a few convenience facilities:\r\n\r\n* `Request.UrlParams` is a `map[string]string` of any ids plucked from route URLs\r\n* `Request.Params` is a `map[string]interface{}` of GET/POST parameters, or the deserialized POST body of a request sent with `Content-Type: application/json`\r\n* `Request.User` provides a hook into Gadget's lightweight authentication system\r\n* `Request.Debug()` gives you per-request debug status\r\n\r\n#### Response objects\r\n\r\nIn most cases, returning a status code and a response body are all you need to\r\ndo to respond to a request. When you do need to set cookies or response\r\nheaders, you can wrap the response body value in `gadget.NewResponse` and set\r\ncookies and headers on the value returned.\r\n\r\n```Go\r\nresp := gadget.NewResponse(responseMap)\r\nresp.AddCookie(&http.Cookie{\r\n\tName:    \"lastVisited\",\r\n\tValue:   r.Path,\r\n\tExpires: time.Now().Add(time.Duration(1) * time.Hour),\r\n})\r\nreturn 200, resp\r\n```\r\n\r\n### Brokers\r\n\r\nThe `interface{}` value you that you return from a controller method is by\r\ndefault piped through `fmt.Sprint`. Strings are predictable, as are numbers;\r\nother types look more like debugging output. However, Gadget has a mechanism\r\nfor transforming those values based on `Content-Type` or `Accept` headers. By\r\ndefining Broker functions and assigning them to MIME types, you can make the\r\nsame controller methods speak HTML and JSON.\r\n\r\n```Go\r\napp.Accept(\"application/json\").Via(gadget.JsonBroker)\r\n```\r\n\r\nJSON and XML processors are included with Gadget. Placing the line above in\r\nyour app's `Configure` method will make Gadget serialize the body values\r\nreturned from your controller methods when the appropriate headers are found in\r\nthe request.\r\n\r\nSubpackage `gadget/template` implements an HTML Broker that wraps the\r\n`html/template` package.\r\n\r\n### Users\r\n\r\nGadget doesn't have an authentication framework, but it does have hooks for\r\nplugging one in. It defines: \r\n\r\n* An interface `gadget.User` that has a single method, `Authenticated() bool`\r\n* A default anonymous user (`Authenticated()` always returns false) \r\n* A function type `UserIdentifier` with the signature `func(*Request) User`\r\n\r\nYou define a type that implements `gadget.User` (presumably for which\r\n`Authenticated()` always returns true and then write a `UserIdentifier` that\r\nwill return either your type or `gadget.AnonymousUser`. You can then register\r\nit with the framework by passing it to `gadget.IdentifyUsersWith`. In your\r\ncontroller methods you'll be able to do something like this:\r\n\r\n```Go\r\nif !r.User.Authenticated() {\r\n\treturn 403, \"Unauthorized\"\r\n}\r\nuser := r.User.(*models.User)\r\n```\r\n\r\n### Debugging\r\n\r\nThe \"serve\" command registered by package `github.com/redneckbeard/gadget/env`\r\ndefines a debug flag. You can access that flag as `env.Debug`. You write a lot\r\nof code inside controller methods, so as a convenience, you can check the value\r\nof `env.Debug` by calling `Request.Debug`.\r\n\r\nIf you need per-request debug state -- for example, seeing debugging variables\r\nin the browser for an administrative user -- you can hook into\r\n`Request.Debug()` by setting `gadget.SetDebugWith` to a function you define\r\nwith the signature `func(*Request) bool`.\r\n\r\n### Custom command line tools\r\n\r\nGadget uses [Quimby](http://github.com/redneckbeard/quimby) to support multiple\r\ncommands from the same binary. You can just as easily register your own. Follow\r\nthe example in the Quimby README.\r\n\r\n## Sites using Gadget\r\n\r\nGadget is used by [farmr.org](http://farmr.org), New England's 4th most popular\r\nwebsite about database-driven urban farm management.","google":"UA-43853030-2","note":"Don't delete this file! It's used internally to help with page regeneration."}